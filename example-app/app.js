
// NOTE: App.js must be bundled with Browserify and
// Jadeify before use. Use the gulp bundle or gulp watch
// commands to generate bundle.js.

(function() {


	// =========================
	// Query Builder Example App
	// =========================


	// Models
	// ==================================================
	// Each model represents a single SQL clause defined
	// by the user. I.e. each SELECT, JOIN, WHERE, etc.
	// is represented as a model in a Backbone
	// collection.

	var Join   = Backbone.Model.extend();
	var Select = Backbone.Model.extend();
	var Where  = Backbone.Model.extend();

	// The "Table" model is a special case. It represents
	// a table defined in the schema.

	var Table = Backbone.Model.extend({
		idAttribute: 'name',
	});


	// Set Attributes
	// ==================================================
	// Every time a user enters input, setAttribute is 
	// called on the related model to apply data from the
	// DOM to the model. "Selection" is a jquery selector
	// for a row of inputs/selects.

	Join.prototype.setAttributes = function(selection) {
		this.set({
			name   : $(selection[0]).val(),
			joinId : $(selection[0].options[selection[0].selectedIndex]).data('join-id'),
			as     : $(selection[0].options[selection[0].selectedIndex]).text()
		});
	};

	Select.prototype.setAttributes = function(selection) {
		this.set({
			joinId    : $(selection[0].options[selection[0].selectedIndex]).data('join-id'),
			name      : $(selection[0]).val(),
			functions : $(selection[1]).val() || undefined,
			groupBy   : $(selection[2]).is(':checked')
		});
	};

	Where.prototype.setAttributes = function(selection) {
		this.set({ 
			field: {
				name   : $(selection[0]).val(),
				joinId : $(selection[0].options[selection[0].selectedIndex]).data('join-id')
			}, 
			operator: $(selection[1]).val() || 'equals', 
			match: { value: $(selection[2]).val() || '' } 
		});
	};



	// Validation
	// ==================================================
	// It's easy to create invalid models with the UI, 
	// usually by leaving a required field blank. Rather
	// than display validation errors to the user, we
	// just ignore any invalid models when building the 
	// query.

	Join.prototype.validate = function(attr) {
		if (!attr.joinId) {
			// Assume isRoot. Check that table exists in schema.
			var join = tables.findWhere({ name: attr.name });
			if (!join) { return 'Invalid join'; }
		}

		else {
			// Check exists in schema & can be joined from source.
			var join   = qb.joinSet.collection.get(attr.joinId);
			var name   = join ? join.get('name') : false;
			var table  = tables.findWhere({ name: name });
			var joins  = table ? table.get('joins') : false;
			var joined = _.findWhere(joins || [], { name: attr.name });
			if (!joined) { return 'Invalid join.'; }
		} 
	};


	// Check that selected field exists in schema.
	Select.prototype.validate = function(attr) {
		var join      = qb.joinSet.collection.get(attr.joinId);
		var joinTable = tables.findWhere({ name: join ? join.get('name') : false });
		var columns   = joinTable ? joinTable.get('columns') : [];
		var selected  = _.findWhere(columns, { name: attr.name });
		if (!selected) { return 'Invalid selection.'; }
	};


	// Check that field exists in schema.
	Where.prototype.validate = function(attr) {
		var join      = qb.joinSet.collection.get(attr.field.joinId);
		var joinTable = tables.findWhere({ name: join ? join.get('name') : false });
		var columns   = joinTable ? joinTable.get('columns') : [];
		var selected  = _.findWhere(columns, { name: attr.field.name });
		if (!selected) { return 'Invalid filter.'; }
	};



	// Collections
	// ==================================================
	// Selects, joins, etc. are all stored in their own
	// collection. The special Tables collection is
	// generated by Query Builder server side and
	// populated locally with a fetch(). It is a map of 
	// the db, primarily used to join tables.

	var Joins   = Backbone.Collection.extend();
	var Selects = Backbone.Collection.extend();
	var Wheres  = Backbone.Collection.extend();
	var Tables  = Backbone.Collection.extend({
		model: Table, url: '/api/schema'
	});

	var tables = new Tables();



	// Extend Backbone View
	// ==================================================
	// These helper functions will be available to every
	// view in the app.

	// Default init behavior. Listen() is a recyclable
	// function meant to contain event listener setup.

	Backbone.View.prototype.initialize = function(params) {
		_.extend(this, params);
		this.childViews = [];
		this.listen();
	};


	// Make the DB schema available inside all templates.
	Backbone.View.prototype.tables = tables;


	// Default render behavior.
	Backbone.View.prototype.render = function() {
		this.$el.html(this.template(this));
		this.trigger('render');
		this.delegateEvents(this.events);
		return this;
	};


	// Noop to be overwritten with listener declarations.
	Backbone.View.prototype.listen = function() {};


	// Overwrite default remove function so that it also
	// removes models from collections and self from parent.

	Backbone.View.prototype.remove = function() {
		if (this.model && this.collection) {
			this.collection.remove(this.model);
		}

		if (this.parent) {
			var index = this.parent.childViews.indexOf(this);
			this.parent.childViews.splice(index, 1);
		}

		this.$el.remove();
		this.stopListening();
		return this;
	};


	// Call remove recursively on each childView and
	// remove from parent collection.

	Backbone.View.prototype.removeChildren = function() {
    _.each(this.childViews, function(child) {
      child.removeChildren();
    });
    this.remove();
    this.childViews = [];
    return this;
	};


	// Call render on this and every childView in array.
	Backbone.View.prototype.renderChildren = function() {
		var that = this;
    _.each(this.childViews, function(child) {
      child.render().$el.appendTo(that.$('.content').first());
      child.renderChildren.call(child);
    });
    return this;
	};



	// QueryBuilder View
	// ==================================================
	// QueryBuilder (initialized as qb) is the root view
	// of the app.


	var QueryBuilder = Backbone.View.extend({
		el: '#app-goes-here',
		template: require('./templates/query-builder.jade'),
		events: { 'submit': 'build', 'click .add-filter': 'addFilter' }
	});


	QueryBuilder.prototype.listen = function() {
		var that = this;

		// QueryBuilder attaches an event listener to
		// its own render event.
		this.listenTo(this, 'render', function() {

			// Create and render a JoinSet (a fieldset
			// of JOIN inputs)

			that.joinSet = new JoinSet({ 
				el: '.joins',
				isRoot: true,
				collection: new Joins(),
			});
			that.joinSet.render();

			// Construct a SelectSet (fieldset of SELECT
			// inputs) but do not render it yet.

			that.selectSet = new SelectSet({ 
				el: '.selects',
				isRoot: true,
				collection: new Selects()
			});

			// Fieldset of WHERE's, not rendered yet.
			that.whereSet = new WhereSet({
				el: '.wheres',
				isRoot: true,
				collection: new Wheres()
			});

		});
	};


	// Build SQL
	// ==================================================
	// Submit collections to server and display result.


	// Submit form and fetch SQL from server.
	QueryBuilder.prototype.build = function(e) {
		e.preventDefault();
		var that = this;

		if (!this.result) { this.result = new Result(); }

		// Validate each collection and remove invalid models.
		_.each([this.joinSet, this.selectSet, this.whereSet], function(set) {
			set.collection.each(function(model) {
				if (!model.isValid()) { set.collection.remove(model); }
			});
		});

		// Don't submit query if joins collection is empty.
		if (this.joinSet.collection.isEmpty()) {
			that.result.status = 'error';
			that.result.result = 'Query includes no tables.';
			return that.result.render();
		}

		// Build query object 
		this.query = {
			joins   : this.joinSet.collection.toJSON(),
			selects : this.selectSet.collection.toJSON(),
			wheres  : this.whereSet.collection.toJSON()
		};

		// Post stringified data to server.
		var queryString = JSON.stringify(this.query);
		var req = $.post('/api/build', { data: queryString });

		// On successful POST.
		req.done(function(res) {
			_.extend(that.result, res);
			that.result.render();
		});

		// Assume request only fails if Node isn't running.
		req.fail(function(err, status) {
			that.result.status = 'browserOnly';
			that.result.render();
		});
	};



	QueryBuilder.prototype.addFilter = function(e) {
		this.whereSet.render();
	};


	// Construct QueryBuilder view in global scope.
	window.qb = new QueryBuilder();



	// Result View
	// ==================================================
	// A simple panel for displaying QB results/errors.

	var Result = Backbone.View.extend({
		template: require('./templates/result.jade'),
		el: '#result'
	});



	// Input View Base Class
	// ==================================================
	// Join, select, filter, and group views are all very
	// similar. To keep things nice and DRY, all four
	// inherit their functionality from the generic base
	// class, InputView. A single inputView corresponds
	// to a single SQL clause represented by a single
	// Backbone model.

	var InputView = Backbone.View.extend();


	InputView.prototype.events = {
		'change select, input' : 'selectInput',
		'click .add-btn'       : 'addInput',
		'click .remove-btn'    : 'removeInput'
	};


	// When the joinSet updates, rebuild all models.
	InputView.prototype.listen = function() {
		var that = this;
		this.listenTo(qb.joinSet.collection, 'add remove change', function() {
			that.selectInput();
		});
	};


	InputView.prototype.removeInput = function(e) {
		e.stopImmediatePropagation();
		this.removeChildren().remove();

		var parentIsFieldset = this.parent instanceof Fieldset;
		var parentIsEmpty    = _.isEmpty(this.parent.childViews);

		if (parentIsFieldset && parentIsEmpty) {
			this.parent.remove();
		}
	};


	// Add a new input group to the DOM.
	InputView.prototype.addInput = function(e) {
		e.stopImmediatePropagation();

		// If this is the top view in a fieldset.
		if (this.isRoot) {
			var siblingView = new this.View({
				ParentView: this.ParentView,
				View: this.View,
				parent: this,
				collection: this.collection
			});

			var targetEl = this.parent.$('.content').first();
			this.childViews.push(siblingView);
			siblingView.render().$el.appendTo(targetEl);
		}

		else {
			var fieldset = new this.ParentView({
				collection: this.collection,
				model: this.model,
				parent: this
			});

			this.childViews.push(fieldset);
			fieldset.render().$el.appendTo(this.$('.content').first());
		}
	};


	// Create/set this.model from user selections in the DOM.
	InputView.prototype.selectInput = function(e) {
		if (e) { e.stopImmediatePropagation(); }
		var that = this;


		var model = this.model;
		if (!model) { model = new this.Model({ id: Number(_.uniqueId()) }); }

		var selections = this.$('select, input');
		model.setAttributes(selections);

		if (model.isValid()) {
			this.model = model;
			this.collection.add(model);
		}

		this.render().renderChildren();
	};


	InputView.prototype.functionsList = [
		{ 
			group: 'Default', 
			options: [
				{ label: 'Each', value: '' }
			]
		},{ 
			group: 'Aggregators', 
			options: [
				{ label: 'Count of', value: 'count' }, 
				{ label: 'Sum of', value: 'sum' }] 
		},{ 
			group: 'Date formatters', 
			options: [
				{ label: 'Day of', value: 'day' }, 
				{ label: 'Month of', value: 'month' }, 
				{ label: 'Quarter of', value: 'quarter' }, 
				{ label: 'Year of', value: 'quarter' }
			]
		}
	];

	InputView.prototype.operators = [
		{ label: 'Equals', value: 'equals' },
		{ label: 'Does not equal', value: 'notEqual' },
		{ label: 'Greater than', value: 'gt' },
		{ label: 'Greater or equal to', value: 'gte' },
		{ label: 'Less than', value: 'lt' },
		{ label: 'Less or equal to', value: 'lte' }
	];



	// Input Views
	// ==================================================

	var JoinView = InputView.extend({
		template: require('./templates/join.jade'),
		Model: Join
	});


	var SelectView = InputView.extend({
		template: require('./templates/select.jade'),
		Model: Select
	});


	var WhereView = InputView.extend({
		template: require('./templates/where.jade'),
		Model: Where
	});



	// Fieldset Views
	// ==================================================

	var Fieldset = Backbone.View.extend({
		template: require('./templates/fieldset.jade')
	});


	// When fieldset is rendered, rerender or create
	// child view(s).

	Fieldset.prototype.listen = function() {
		var that = this;
		this.listenTo(this, 'render', function() {

			// If children already exist, render them and return.
			if (that.childViews.length > 0) {
				return that.renderChildren();
			}

			// Else create a new childView and render it.
			var childView = new that.ChildView({
				View: that.ChildView,
				ParentView: that.View,
				isRoot: true,
				parent: that,
				collection: that.collection
			});

			that.childViews.push(childView);
			childView.render().$el.appendTo(that.$('.content').first());
		});
	};


	var JoinSet = Fieldset.extend({
		ChildView: JoinView,
		label: 'Include'
	});

	JoinSet.prototype.View = JoinSet;


	var SelectSet = Fieldset.extend({
		ChildView: SelectView,
		label: 'Select'
	});

	SelectSet.prototype.listen = function() {
		Fieldset.prototype.listen.call(this);
		this.listenToOnce(qb.joinSet.collection, 'add', this.render);
		this.listenTo(qb.joinSet.collection, 'add remove change', this.renderChildren);
	};

	SelectSet.prototype.View = SelectSet;


	var WhereSet = Fieldset.extend({
		ChildView: WhereView,
		label: 'Filter'
	});

	WhereSet.prototype.listen = function() {
		Fieldset.prototype.listen.call(this);
		this.listenTo(qb.joinSet.collection, 'add remove change', this.renderChildren);
	};

	WhereSet.prototype.View = WhereSet;



	// Start app
	// ==================================================
	// Fetch the schema then render the root view. This
	// code is meant to run regardless of whether
	// QueryBuilder is actually available via API (on
	// Github Pages for example), so if the fetch to the
	// server fails, use cached schema instead. This
	// way the UI will function normally, though it will
	// not be able to reach the server to retrive SQL.

	var browserOnly = false;
	var cachedSchema = require('./cached-schema.json');

	window.tables = tables;

	tables.on('sync', function()  { qb.render(); });
	tables.on('error', function() { useCachedSchema(); });
	tables.fetch();

	function useCachedSchema() {
		tables.reset(cachedSchema);
		browserOnly = true;
		qb.render();
	}


})()